#!/usr/bin/python

from utils import to_unicode, to_bytes
from cue import read_cue

import formats

from optparse import OptionParser, OptionGroup
from tempfile import mkdtemp
from itertools import chain

import collections
import subprocess
import shutil
import sys
import os

ILLEGAL_CHARACTERS_MAP = {
	u"\\": u"-",
	u":": u"-",
	u"*": u"+",
	u"?": u"_",
	u'"': u"'",
	u"<": u"(",
	u">": u")",
	u"|": u"-"
}

progname = os.path.basename(sys.argv[0])

def printf(fmt, *args):
	out = fmt % args
	sys.stdout.write(out)

	if out[-1] != '\n':
		sys.stdout.flush()

def printerr(fmt, *args):
	msg = fmt % args
	if msg[-1] != "\n":
		msg += "\n"
	sys.stderr.write("** " + progname + ": " + msg)

def debug(fmt, *args):
	msg = fmt % args
	if msg[-1] != "\n":
		msg += "\n"
	sys.stderr.write("-- " + msg)

try:
	import config
except Exception as err:
	printerr("import config failed: %s", err)
	sys.exit(0)

def quote(s, ch = '"'):
	return s if " " not in s else ch + s + ch

def msf(ts):
	m = ts / (60 * 75)
	s = ts / 75 % 60
	f = ts % 75

	return "%d:%02d:%02d" % (m, s, f)

class TempLink:
	def __init__(self, path, name):
		self.tmpdir = mkdtemp(prefix = "temp-")
		self.linkpath = "%s/%s" % (self.tmpdir, name)

		try:
			os.symlink(path, self.tmpdir + "/" + name)
		except Exception as err:
			os.rmdir(self.tmpdir)
			raise err

	def remove(self):
		os.unlink(self.linkpath)
		os.rmdir(self.tmpdir)

	def __repr__(self):
		return "TempLink('%s')" % self.linkpath

	def __str__(self):
		return self.linkpath

	def __enter__(self):
		return self

	def __exit__(self, *args):
		self.remove()

def print_cue(cue):
	for k, v in cue.attrs():
		printf("%s: %s\n", k.upper(), quote(v))

	for file in cue.files():
		name = cue.dir + file.name

		printf("FILE %s", quote(file.name))
		if not os.path.exists(name):
			printf(": not exists\n")
		else:
			info = StreamInfo.get(name)
			if not info:
				printf(": unknown type\n")
			else:
				printf(" [%s] (%d/%d, %d ch)\n",
					info.type,
					info.bits_per_sample,
					info.sample_rate,
					info.channels)

		for track in file.tracks():
			printf("\tTRACK %02d", track.number)
			title = track.get("title")
			if title != "":
				printf(" %s", quote(title))
			printf(": %s -", msf(track.begin))
			if track.end is not None:
				printf(" %s", msf(track.end))
			printf("\n")

			for k, v in track.attrs():
				if k not in ("pregap", "postgap", "title"):
					printf("\t\t%s: %s\n", k.upper(), quote(v))

def parse_args():
	parser = OptionParser(usage = u"Usage: %prog [options] cuefile")
	parser.add_option("--ignore",
		action="store_true", default=False, dest="ignore",
		help="ignore cue parsing errors")

	parser.add_option("--dump",
		dest="dump", choices=["cue", "tags", "tracks"],
		metavar="cue|tags|tracks",
		help="print the cue sheet, file tags or track names")

	parser.add_option("-n", "--dry-run",
		action="store_true", default=False, dest="dry_run")

	enc = OptionGroup(parser, "Encoding options")

	enc.add_option("-t", "--type", dest="type",
		choices = formats.supported() + ["help"],
		help="output file format")

	enc.add_option("--coding", dest="coding",
		help="encoding of original text")

	enc.add_option("-d", "--dir",
		dest="dir", default=config.DIR, help="output directory")

	enc.add_option("--use-tempdir",
		dest="use_tempdir", action="store_true",
		help="use temporary directory for files")

	enc.add_option("--no-tempdir",
		dest="use_tempdir", action="store_false",
		help="do not use temporary directory")

	enc.add_option("-C", "--compression", type="int",
		dest="compression", metavar="FACTOR",
		help="compression factor for output format (used for flac, ogg)")

	enc.add_option("--bitrate", type="int",
		dest="bitrate", default=config.MP3_BITRATE,
		help="audio bitrate (used for mp3)")

	parser.add_option_group(enc)

	fname = OptionGroup(parser, "Filename options")

	fname.add_option("--format",
		dest="fmt", default=config.FILENAME_FORMAT,
		help="the format string for new filenames")

	fname.add_option("--convert-chars",
		dest="convert_chars", action="store_true",
		help="replace illegal characters in filename")

	fname.add_option("--no-convert-chars",
		dest="convert_chars", action="store_false",
		help="do not replace characters in filename")

	parser.add_option_group(fname)

	format = OptionGroup(parser, "Output format")

	format.add_option("-r", "--sample-rate", type="int",
		dest="sample_rate", default=config.SAMPLE_RATE, metavar="RATE")

	format.add_option("-c", "--channels", type="int",
		dest="channels", default=config.CHANNELS)

	format.add_option("-b", "--bits-per-sample", type="int",
		dest="bits_per_sample", default=config.BITS_PER_SAMPLE, metavar="BITS")

	parser.add_option_group(format)

	tag = OptionGroup(parser, "Tag options")
	tag_options = ["album", "artist", ("date", "year"), "genre",
		"comment", "composer", "albumartist"]

	for opt in tag_options:
		if type(opt) in (list, tuple):
			tag.add_option(*["--" + s for s in opt], dest=opt[0], default="")
		else:
			tag.add_option("--" + opt, dest=opt, default="")

	parser.add_option_group(tag)

	return parser.parse_args()

def option_check_range(option, value, min, max):
	if value is not None and (value < min or value > max):
		printerr("invalid %s value %d, must be in range %d .. %d", option, value, min, max)
		return False

	return True

def process_options(opt):
	def choose(a, b):
		return a if a is not None else b

	if opt.type == "help":
		printerr("supported formats: " + " ".join(formats.supported()))
		return False

	if opt.type is None and config.TYPE:
		if not formats.issupported(config.TYPE):
			printerr("invalid configuration: type '%s' is not supported", config.TYPE)
			return False

		opt.type = config.TYPE

	if not opt.dump and opt.type is None:
		printerr("--type option is missed")
		return False

	if opt.type == "flac":
		opt.compression = choose(opt.compression, config.FLAC_COMPRESSION)
		if not option_check_range("compression", opt.compression, 0, 8):
			return False
	elif opt.type == "ogg":
		opt.compression = choose(opt.compression, config.OGG_COMPRESSION)
		if not option_check_range("compression", opt.compression, -1, 10):
			return False
	elif opt.type == "mp3":
		if not option_check_range("bitrate", opt.bitrate, 32, 320):
			return False

	if not opt.dir:
		opt.dir = u"."
	else:
		opt.dir = to_unicode(os.path.normpath(opt.dir))

	opt.fmt = to_unicode(opt.fmt)
	if not os.path.basename(opt.fmt):
		printerr("invalid format option \"%s\"", opt.fmt)
		return False
	else:
		opt.fmt = os.path.normpath(opt.fmt)
		if opt.fmt.startswith("/"):
			opt.fmt = opt.fmt[1:]

	if opt.convert_chars is None:
		opt.convert_chars = config.CONVERT_CHARS
	if opt.use_tempdir is None:
		opt.use_tempdir = config.USE_TEMPDIR

	return True

def filterdir(dir, prefix):
	return sorted(filter(lambda f: f.startswith(prefix), os.listdir(dir)))

def mkdir(path):
	if not os.path.exists(path):
		try:
			os.makedirs(path)
		except OSError as err:
			printerr("make dir %s failed: %s", quote(path), err)
			sys.exit(1)

def convert_characters(path):
	return "".join([ILLEGAL_CHARACTERS_MAP.get(ch, ch) for ch in path])

class StreamInfo:
	__mapping = {
		b"Channels:": "channels",
		b"Bits/sample:": "bits_per_sample",
		b"Samples/sec:": "sample_rate"
	}

	@staticmethod
	def get(name):
		info = StreamInfo()
		proc = subprocess.Popen(["shninfo", name], stdout = subprocess.PIPE)
		for line in proc.stdout.readlines():
			data = line.split()
			attr = StreamInfo.__mapping.get(data[0])
			if attr:
				setattr(info, attr, int(data[1]))
			elif line.startswith(b"Handled by:"):
				info.type = to_unicode(data[2])

		if proc.wait():
			return None

		return info

class CueSplitter:
	EXT = ["ape", "flac", "wv"]

	class File:
		def __init__(self, fileobj, name, info):
			self.fileobj = fileobj
			self.name = name
			self.info = info

		def __getattr__(self, attr):
			return getattr(self.fileobj, attr)

	class TrackInfo:
		def __init__(self, name, tags):
			self.name = name
			self.tags = tags

	@staticmethod
	def format_by_tags(fmt, tags, replace=False):
		if replace:
			def conv(var):
				if isinstance(var, str):
					return var.replace("/", "-")
				return var

			tags = {k: conv(v) for k, v in tags.items()}

		try:
			return fmt.format(year=tags["date"], **tags)
		except KeyError as err:
			printerr("invalid format key: %s", err)
			sys.exit(1)
		except ValueError as err:
			printerr("invalid format option: %s", err)
			sys.exit(1)

	def __init__(self, cue, opt):
		self.cue = cue
		self.opt = opt
		self.tracktotal = len(list(self.all_tracks()))

		self.enctype = formats.handler(opt.type, logger=printf)

		self.tags = {
			"album": self.opt.album or self.cue.get("title"),
			"date": self.opt.date or self.cue.get("date"),
			"genre": self.opt.genre or self.cue.get("genre"),
			"comment": self.opt.comment or self.cue.get("comment"),
			"composer": self.opt.composer
				or self.cue.get("songwriter"),
			"artist": self.opt.albumartist or self.opt.artist
				or self.cue.get("performer"),
			"albumartist": self.opt.albumartist
		}

		tmp = self.format_by_tags(os.path.dirname(opt.fmt), self.tags, True)

		if opt.convert_chars:
			tmp = convert_characters(tmp)

		self.dest = os.path.join(opt.dir, tmp)
		track_fmt = os.path.basename(opt.fmt)

		tracknumber = 0
		self.track_info = {}
		for track in self.all_tracks():
			tracknumber += 1
			self.track_info[track] = self.get_track_info(
				track, tracknumber, track_fmt
			)

	def get_track_info(self, track, tracknumber, fmt):
		tags = dict(self.tags)
		tags.update({
			"tracknumber": tracknumber,
			"tracktotal": self.tracktotal,

			"title": track.get("title") or "track",
			"artist": self.opt.artist or track.get("performer")
				or self.cue.get("performer"),
			"composer": self.opt.composer or track.get("songwriter")
				or self.cue.get("songwriter")
		})

		name = self.format_by_tags(fmt, tags).replace("/", "-")

		if self.opt.convert_chars:
			name = convert_characters(name)

		return self.TrackInfo(name + "." + self.enctype.ext, tags)

	def find_realfile(self, name):
		if not name.endswith(".wav"):
			return None

		orig = name.rpartition(".")[0]
		for file in filterdir(self.cue.dir or ".", orig):
			head, _, ext = file.rpartition(".")
			if head == orig and ext in self.EXT:
				return file

		return None

	def open_files(self):
		lst = []

		for file in self.cue.files():
			if not file.has_audio_tracks():
				debug("skip file %s: no tracks", quote(file.name))
				continue

			name = self.cue.dir + file.name
			if not os.path.exists(name):
				real = self.find_realfile(file.name)
				if not real:
					printerr("no such file %s", quote(file.name))
					sys.exit(1)
				name = self.cue.dir + real

			info = StreamInfo.get(name)
			if info is None:
				printerr("%s: unknown type", quote(file.name))
				sys.exit(1)

			lst.append(self.File(file, name, info))

		return lst

	def shntool_args(self, tool, info):
		encode = self.enctype.encode(self.opt, info)
		return [tool, "-w", "-d", self.dest, "-o", encode]

	def track_name(self, track):
		return self.track_info[track].name

	def track_tags(self, track):
		return self.track_info[track].tags

	def tag(self, track, path):
		printf("Tag [%s] : ", path)
		if not self.enctype.tag(path, self.track_tags(track)):
			printf("FAILED\n")
			sys.exit(1)

		printf("OK\n")

	def copy_file(self, file):
		noteq = lambda a, b: a and a != b

		if file.info.type != self.encode.name:
			return False
		if noteq(self.opt.sample_rate, file.info.sample_rate):
			return False
		if noteq(self.opt.bits_per_sample, file.info.bits_per_sample):
			return False
		if noteq(self.opt.channels, file.info.channels):
			return False

		track = list(file.tracks())[0]
		trackname = self.track_name(track)
		path = os.path.join(self.dest, trackname)

		if self.opt.dry_run:
			printf("Copy [%s] --> [%s]\n", file.name, path)
			return True

		printf("Copy [%s] --> [%s] : ", file.name, path)

		try:
			shutil.copyfile(file.name, path)
		except Exception as err:
			printf("FAILED: %s\n", err)
			sys.exit(1)
		else:
			printf("OK\n")

		self.tag(track, path)

		return True

	def convert_file(self, file):
		track = list(file.tracks())[0]
		trackname = self.track_name(track)

		args = self.shntool_args("shnconv", file.info)

		if self.opt.dry_run:
			name = "link to " + quote(file.name, "'")
			debug("run %s", " ".join(map(quote, args + [name])))
			return

		try:
			link = TempLink(os.path.abspath(file.name), trackname)
		except OSError as err:
			printerr("create symlink %s failed: %s", quote(trackname), err)
			sys.exit(1)

		ret = subprocess.call(args + [str(link)])
		link.remove()

		if ret:
			printerr("shnconv failed: exit code %d", ret);
			sys.exit(1)

		self.tag(track, os.path.join(self.dest, trackname))

	def split_file(self, file, points):
		args = self.shntool_args("shnsplit", file.info) + [file.name]

		if self.opt.dry_run:
			debug("run %s", " ".join(map(quote, args)))
			return

		proc = subprocess.Popen(args, stdin = subprocess.PIPE)
		proc.stdin.write(to_bytes("\n".join(map(str, points))))
		proc.stdin.close()

		if proc.wait():
			printerr("shnsplit failed: exit code %d", proc.returncode)
			sys.exit(1)

		splitted = filterdir(self.dest, "split-track")
		for track, filename in zip(file.tracks(), splitted):
			trackname = self.track_name(track)
			path = os.path.join(self.dest, trackname)

			printf("Rename [%s] --> [%s] : ", filename, trackname)
			try:
				os.rename(os.path.join(self.dest, filename), path)
			except OSError as err:
				printf("FAILED: %s\n", err)
				sys.exit(1)
			else:
				printf("OK\n")

			self.tag(track, path)

	def check_duplicates(self):
		names = [x.name for x in self.track_info.values()]
		dup = [k for k, v in collections.Counter(names).items() if v > 1]
		if dup:
			printerr("track names are duplicated: %s", " ".join(dup))
			sys.exit(1)

	def transfer_files(self, source, dest):
		for file in sorted(os.listdir(source)):
			path = os.path.join(source, file)
			if not os.path.isfile(path):
				debug("skip non file %s", quote(file))
				continue

			printf("Copy [%s] into [%s] : ", file, dest)

			try:
				shutil.copy(path, dest)
			except Exception as err:
				printf("FAILED: %s\n", err)
				sys.exit(1)
			else:
				printf("OK\n")

	def split(self):
		self.check_duplicates()

		files = self.open_files()

		self.realpath = None
		if not self.opt.dry_run:
			mkdir(self.dest)
			if self.opt.use_tempdir:
				self.realpath = self.dest
				tempdir = mkdtemp(prefix="cutter-")
				self.dest = to_unicode(tempdir)

		for file in files:
			points = list(file.split_points(file.info))
			if not points:
				if not self.copy_file(file):
					self.convert_file(file)
			else:
				self.split_file(file, points)

		if self.realpath:
			self.transfer_files(self.dest, self.realpath)
			try:
				shutil.rmtree(self.dest)
			except Exception as err:
				printerr("rm %s failed: %s\n", self.dest, err)
				sys.exit(1)

	def all_tracks(self):
		return chain(*[f.tracks() for f in self.cue.files()])

	def dump_tags(self):
		add_line = False
		for track in self.all_tracks():
			if add_line:
				printf("\n")
			add_line = True

			tags = self.track_tags(track)
			for k, v in sorted(tags.items()):
				if v is not "":
					printf("%s=%s\n", k.upper(), v)

	def dump_tracks(self):
		for track in self.all_tracks():
			trackname = self.track_name(track)
			printf("%s\n", os.path.join(self.dest, trackname))

def find_cuefile(path):
	for file in os.listdir(path):
		fullname = os.path.join(path, file)
		if os.path.isfile(fullname) and file.endswith(".cue"):
			return fullname

	printerr("no cue file")
	sys.exit(1)

def main():
	options, args = parse_args()
	if not process_options(options):
		sys.exit(1)

	if len(args) != 1:
		printf("Usage: %s [options] cuefile\n", progname)
		return 1

	def on_error(err):
		printerr("%d: %s\n" % (err.line, err))
		if not options.ignore:
			raise StopIteration

	cuepath = to_unicode(args[0])
	if os.path.isdir(cuepath):
		cuepath = find_cuefile(cuepath)
		if options.dry_run:
			debug("use cue file %s", quote(cuepath))

	try:
		cue = read_cue(cuepath, options.coding, on_error=on_error)
	except StopIteration:
		return 1
	except IOError as err:
		printerr("open %s: %s", err.filename, err.strerror)
		return 1
	except Exception as err:
		msg = "%s (%s)" % (err, err.__class__.__name__)

		if hasattr(err, "filename"):
			printerr("%s: %s: %s\n", err.filename, msg)
		else:
			printerr("%s\n", msg)

		return 1

	cue.dir = os.path.dirname(cuepath)
	if cue.dir:
		cue.dir += "/"

	{
		"cue":		lambda: print_cue(cue),
		"tags":		lambda: CueSplitter(cue, options).dump_tags(),
		"tracks":	lambda: CueSplitter(cue, options).dump_tracks(),
		None:		lambda: CueSplitter(cue, options).split()
	}[options.dump]()

	return 0

if __name__ == '__main__':
	sys.exit(main())
